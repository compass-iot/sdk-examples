# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: platform/v1/unary.proto, platform/v1/streaming.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime
from typing import List

import betterproto

from sdk.compass import v1


class SelectionType(betterproto.Enum):
    """
    message NearMiss {  //TODO}message NearMissResponse {  repeated NearMiss
    events = 1;} Behaviour on what is considered a "trip" with regards to O and
    D
    """

    # Include any trip with at least one point within the zone selection.
    POLYGON_PASSING_THROUGH = 0
    # Include trips where the first point is within in the zone selection.
    POLYGON_STARTING_IN = 1
    # Include trips where the last points is within the zone selection.
    POLYGON_ENDING_IN = 2
    # Include trips that have traversed the exact route highlighted.
    LINESTRING_FULL_MATCH = 3
    # Include trips that have intersected with the route highlighted, in at least
    # one section of the road.
    LINESTRING_PARTIAL_MATCH = 4


class RawRequestFilter(betterproto.Enum):
    """Filter stream to only give points with specific attributes"""

    UNSPECIFIED = 0
    NEAR_MISS = 1
    IRI = 2


class StreamEnvironment(betterproto.Enum):
    """Non empty"""

    DEV = 0
    PROD = 1


@dataclass
class AggregateByPathRequest(betterproto.Message):
    # Linestring in (WKT)[https://www.ogc.org/standards/wkt-crs] format, srid
    # 4326 is assumed, longitude precedes latitude; LINESTRING(151.186035
    # -33.869301, 151.18486 -33.868984999999995) OR Polygon is
    # (WKT)[https://www.ogc.org/standards/wkt-crs] format;
    # POLYGON((117.83836364746094 -28.060912170655488,117.85930633544922
    # -28.060912170655488,117.85930633544922
    # -28.07696808822284,117.83836364746094 -28.07696808822284,117.83836364746094
    # -28.060912170655488))
    linestring_wkt: str = betterproto.string_field(1)
    # DateRange, will have timezone adjusted based on where linestring or polygon
    # is located
    date_time_range: v1.DateTimeRange = betterproto.message_field(2)


@dataclass
class AggregateByPathResponse(betterproto.Message):
    request_id: str = betterproto.string_field(1)
    selection_name: str = betterproto.string_field(3)
    selection_wkt: str = betterproto.string_field(4)
    aggregate: List["PathAggregate"] = betterproto.message_field(5)


@dataclass
class PathAggregate(betterproto.Message):
    total: "PathMetric" = betterproto.message_field(1)
    # Array of length 24, if there is no data available for hour: x then
    # hour_of_day[x] will be null
    hour_of_day: List["PathMetric"] = betterproto.message_field(2)
    # Array of length 7, if there is no data available for day: x then
    # day_of_week[x] will be null day_of_week[0] is sunday day_of_week[6] is
    # saturday
    day_of_week: List["PathMetric"] = betterproto.message_field(3)
    distance_along_path: List["PathMetric"] = betterproto.message_field(5)
    vehicle_type: v1.VehicleType = betterproto.enum_field(4)


@dataclass
class PathMetric(betterproto.Message):
    """
    * Speed is calculated by taking the the 90th percentile of all points in
    given selection for a given trip, this is known as trip speed the next
    aggregations e.g. median, avg, 85pth percentile are calculated over said
    trip speed
    """

    # Sum volume in timeframe; 12345
    daily_average_volume: float = betterproto.float_field(
        1, group="_daily_average_volume"
    )
    total_volume: int = betterproto.uint64_field(2, group="_total_volume")
    # Speed (km/h); 60
    speed: v1.Stat = betterproto.message_field(3)
    # Gforce sqrt(xacc^2 + yacc^2) (units?); 0.58
    gforce: v1.Stat = betterproto.message_field(4)
    # Positive X component of Gforce; -0.5
    positive_xacc: v1.Stat = betterproto.message_field(5)
    # Negative X component of Gforce; -0.5
    negative_xacc: v1.Stat = betterproto.message_field(6)
    # Absolute Y component of Gforce i.e. -0.1 y is treated as 0.1; 0.3
    absolute_yacc: v1.Stat = betterproto.message_field(7)
    # Median travel time in seconds; 420
    travel_time50: float = betterproto.float_field(8, group="_travel_time50")
    iri: v1.Stat = betterproto.message_field(9)
    near_miss_count: int = betterproto.uint32_field(10)


@dataclass
class RawResponse(betterproto.Message):
    events: List[v1.PositionEvent] = betterproto.message_field(1)


@dataclass
class Selection(betterproto.Message):
    # User is responsible for ensuring uniqueness across names.
    name: str = betterproto.string_field(1)
    # Bounds described as a POLYGON OR LINESTRING in
    # (WKT)[https://www.ogc.org/standards/wkt-crs] format, neither left nor right
    # handed system, will try both and take the smaller polyon
    wkt: str = betterproto.string_field(2)
    # It's important to note that `SelectionType` is married to the WKT geography
    # type. Ensure you are using compadible types. Polygons accept
    # `POLYGON_PASSING_THROUGH`, `POLYGON_STARTING_IN` and `POLYGON_ENDING`.
    # Whereas Linestrings accept `LINESTRING_FULL_MATCH` and
    # `LINESTRING_PARTIAL_MATCH`.
    selection_type: "SelectionType" = betterproto.enum_field(3)


@dataclass
class Foo(betterproto.Message):
    foo: str = betterproto.string_field(1)


@dataclass
class InputSelection(betterproto.Message):
    id: int = betterproto.int32_field(1)
    selection: "Selection" = betterproto.message_field(2)


@dataclass
class OriginDestinationRequest(betterproto.Message):
    date_time_range: v1.DateTimeRange = betterproto.message_field(1)
    selection: List["Selection"] = betterproto.message_field(2)


@dataclass
class EdgeSelectionPermutation(betterproto.Message):
    origin_selection_id: int = betterproto.int32_field(1)
    destination_selection_id: int = betterproto.int32_field(2)
    vehicle_type: v1.VehicleType = betterproto.enum_field(4)
    trip_count_percentile: float = betterproto.double_field(3)


@dataclass
class ODEdge(betterproto.Message):
    total_trip_count: int = betterproto.int64_field(1)
    selection_permutations: List[
        "EdgeSelectionPermutation"
    ] = betterproto.message_field(2)
    linestring_wkt: str = betterproto.string_field(3)
    total_trip_count_percentile: float = betterproto.double_field(4)


@dataclass
class OriginDestinationResponse(betterproto.Message):
    inputs: List["InputSelection"] = betterproto.message_field(1)
    edges: List["ODEdge"] = betterproto.message_field(2)
    selection_permutation: List["SelectionPermutation"] = betterproto.message_field(3)
    trip_count_percentile: float = betterproto.double_field(6)


@dataclass
class SelectionPermutation(betterproto.Message):
    origin_selection_id: int = betterproto.int32_field(1)
    destination_selection_id: int = betterproto.int32_field(2)
    vehicle_type: v1.VehicleType = betterproto.enum_field(3)
    travel_time: v1.Stat = betterproto.message_field(4)
    time_in_origin: v1.Stat = betterproto.message_field(10)
    time_in_destination: v1.Stat = betterproto.message_field(11)
    trip_count: int = betterproto.int32_field(5)
    trip_distribution: float = betterproto.float_field(6)
    distance_between_centroid_meters: float = betterproto.float_field(7)
    shortest_road_distance: float = betterproto.float_field(9)
    # should have exactly 23 elements 0 means 12am
    hourly_breakdown: List["SelectionPermutationHourly"] = betterproto.message_field(8)


@dataclass
class SelectionPermutationHourly(betterproto.Message):
    travel_time: v1.Stat = betterproto.message_field(1)
    time_in_origin: v1.Stat = betterproto.message_field(4)
    time_in_destination: v1.Stat = betterproto.message_field(5)
    trip_count_percentage: float = betterproto.float_field(2)
    hour_at_origin: int = betterproto.int32_field(3)


@dataclass
class EdgeAggregateByPolygonRequest(betterproto.Message):
    # Linestring in (WKT)[https://www.ogc.org/standards/wkt-crs] format, srid
    # 4326 is assumed, longitude precedes latitude; LINESTRING(151.186035
    # -33.869301, 151.18486 -33.868984999999995) OR Polygon is
    # (WKT)[https://www.ogc.org/standards/wkt-crs] format;
    # POLYGON((117.83836364746094 -28.060912170655488,117.85930633544922
    # -28.060912170655488,117.85930633544922
    # -28.07696808822284,117.83836364746094 -28.07696808822284,117.83836364746094
    # -28.060912170655488))
    polygon_wkt: str = betterproto.string_field(1)
    # DateRange, will have timezone adjusted based on where linestring or polygon
    # is located
    date_time_selection: v1.DateTimeRange = betterproto.message_field(2)


@dataclass
class ProcessedPointByGeometryRequest(betterproto.Message):
    # Linestring in (WKT)[https://www.ogc.org/standards/wkt-crs] format, srid
    # 4326 is assumed, longitude precedes latitude; LINESTRING(151.186035
    # -33.869301, 151.18486 -33.868984999999995) OR Polygon is
    # (WKT)[https://www.ogc.org/standards/wkt-crs] format;
    # POLYGON((117.83836364746094 -28.060912170655488,117.85930633544922
    # -28.060912170655488,117.85930633544922
    # -28.07696808822284,117.83836364746094 -28.07696808822284,117.83836364746094
    # -28.060912170655488))
    linestring_or_polygon_wkt: str = betterproto.string_field(1)
    # DateRange, will have timezone adjusted based on where linestring or polygon
    # is located
    date_time_range: v1.DateTimeRange = betterproto.message_field(2)
    filters: List["RawRequestFilter"] = betterproto.enum_field(3)


@dataclass
class RealtimeRawPointByGeometryRequest(betterproto.Message):
    # Linestring in (WKT)[https://www.ogc.org/standards/wkt-crs] format, srid
    # 4326 is assumed, longitude precedes latitude; LINESTRING(151.186035
    # -33.869301, 151.18486 -33.868984999999995) OR Polygon is
    # (WKT)[https://www.ogc.org/standards/wkt-crs] format;
    # POLYGON((117.83836364746094 -28.060912170655488,117.85930633544922
    # -28.060912170655488,117.85930633544922
    # -28.07696808822284,117.83836364746094 -28.07696808822284,117.83836364746094
    # -28.060912170655488))
    bounds_wkt: str = betterproto.string_field(1)
    vehicle_ids: List[str] = betterproto.string_field(2)
    stream_env: "StreamEnvironment" = betterproto.enum_field(3)
    max_staleness_minutes: int = betterproto.uint64_field(4)


@dataclass
class PolygonEdgeAggregate(betterproto.Message):
    osm_way_id: int = betterproto.uint64_field(1)
    geom: v1.Path = betterproto.message_field(2)
    vehicle_type: v1.VehicleType = betterproto.enum_field(3)
    date: v1.LocalDate = betterproto.message_field(4)
    base_time_hhmm: int = betterproto.uint32_field(5)
    speed: v1.Stat = betterproto.message_field(6)
    iri: v1.Stat = betterproto.message_field(7)
    unique_vehicles_count: int = betterproto.uint32_field(8)
    near_miss_count: int = betterproto.uint32_field(9)


@dataclass
class ExportResponse(betterproto.Message):
    # Signed url pointing to generated file
    url: str = betterproto.string_field(1)
    # Expiration of generated file
    expiration: datetime = betterproto.message_field(2)
    # Label of best attempt to summarise the request
    label: str = betterproto.string_field(3)


@dataclass
class ProcessedPoint(betterproto.Message):
    vehicle_type: v1.VehicleType = betterproto.enum_field(1)
    date_hour: v1.LocalDateHour = betterproto.message_field(2)
    road_matched_point: v1.LatLng = betterproto.message_field(3)
    speed: float = betterproto.float_field(4)
    acceleration: v1.Acceleration = betterproto.message_field(20, group="_acceleration")
    gyro: v1.Gyro = betterproto.message_field(21, group="_gyro")
    iri: float = betterproto.float_field(22, group="_iri")
    near_miss: "NearMiss" = betterproto.message_field(23, group="_near_miss")


@dataclass
class NearMiss(betterproto.Message):
    type: v1.NearMissType = betterproto.enum_field(1)
    adjacent: List["AdjacentNearMiss"] = betterproto.message_field(2)
    timestamp: datetime = betterproto.message_field(3)


@dataclass
class AdjacentNearMiss(betterproto.Message):
    position: v1.LatLng = betterproto.message_field(1)
    timestamp: datetime = betterproto.message_field(2)
    speed: float = betterproto.float_field(3)
    acceleration: v1.Acceleration = betterproto.message_field(4)
