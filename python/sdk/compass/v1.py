# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: compass/v1/geo.proto, compass/v1/vehicle.proto, compass/v1/aggregate.proto, compass/v1/time.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List

import betterproto


class TransportType(betterproto.Enum):
    """Depcrecated"""

    TRANSPORT_TYPE_UNSPECIFIED = 0
    PRIVATE = 1
    PUBLIC = 2


class VehicleType(betterproto.Enum):
    """type of vehicle being used"""

    VEHICLE_TYPE_UNSPECIFIED = 0
    BUS = 1
    CAR = 2
    VAN = 3
    TRUCK = 4
    LCV = 5
    HCV = 6


class NearMissType(betterproto.Enum):
    """* Type of near miss event"""

    NEAR_MISS_TYPE_NONE = 0
    NEAR_MISS_TYPE_BRAKING = 1
    NEAR_MISS_TYPE_STEERING = 2
    NEAR_MISS_TYPE_COMBINED = 3


class DayOfWeek(betterproto.Enum):
    """Day of the week"""

    SUNDAY = 0
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6


@dataclass
class LatLng(betterproto.Message):
    """
    An object representing a latitude/longitude pair. This is expressed as a
    pair of doubles representing degrees latitude and degrees longitude. Unless
    specified otherwise, this must conform to the <a
    href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
    standard</a>. Values must be within normalized ranges.
    """

    # The latitude in degrees. It must be in the range [-90.0, +90.0].
    lat: float = betterproto.double_field(1)
    # The longitude in degrees. It must be in the range [-180.0, +180.0].
    lng: float = betterproto.double_field(2)


@dataclass
class LatLngTimestamp(betterproto.Message):
    # The latitude in degrees. It must be in the range [-90.0, +90.0].
    lat: float = betterproto.double_field(1)
    # The longitude in degrees. It must be in the range [-180.0, +180.0].
    lng: float = betterproto.double_field(2)
    timestamp: datetime = betterproto.message_field(3)


@dataclass
class LatLng32(betterproto.Message):
    # The latitude in degrees. It must be in the range [-90.0, +90.0].
    latitude: float = betterproto.float_field(1)
    # The longitude in degrees. It must be in the range [-180.0, +180.0].
    longitude: float = betterproto.float_field(2)


@dataclass
class BoundingBox(betterproto.Message):
    north_eastern: "LatLng" = betterproto.message_field(1)
    south_western: "LatLng" = betterproto.message_field(2)


@dataclass
class Circle(betterproto.Message):
    center: "LatLng" = betterproto.message_field(1)
    radius: float = betterproto.double_field(2)


@dataclass
class Path(betterproto.Message):
    points: List["LatLng"] = betterproto.message_field(1)


@dataclass
class Line(betterproto.Message):
    start: "LatLng" = betterproto.message_field(1)
    end: "LatLng" = betterproto.message_field(2)


@dataclass
class Direction(betterproto.Message):
    """
    Examples: Input: N/S/E/W -> use Bearing ⊆ {0, 90, 180, 270}, ErrorMargin =
    90 Input: N/NE/E/SE/S/SW/W/NW use Bearing ⊆ {0, 45, 90, 135, 180, 225, 270,
    315}, ErrorMargin = 45 Input: <Bearing as a number> use Bearing ⊆ [0, 360),
    ErrorMargin = 0 (or 1 if Bearing input is an integer)    type Direction
    struct {Bearing     float64    ErrorMargin float64
    """

    bearing: float = betterproto.double_field(1)
    error_margin: float = betterproto.double_field(2)


@dataclass
class Polygon(betterproto.Message):
    points: List["LatLng32"] = betterproto.message_field(1)


@dataclass
class PositionEvent(betterproto.Message):
    """
    * - Either VehicleID or TripID MUST be present. - Ideally both, followed by
    just VehicleID, followed by just TripID. - Position, VehicleType and
    TransportType are required - Any extra metadata can be added in 'labels'
    and will be greatly appreciated!
    """

    vehicle_id: str = betterproto.string_field(1)
    timestamp: datetime = betterproto.message_field(2)
    transport_type: "TransportType" = betterproto.enum_field(3, group="_transport_type")
    vehicle_type: "VehicleType" = betterproto.enum_field(4, group="_vehicle_type")
    position: "Position" = betterproto.message_field(5)
    acceleration: "Acceleration" = betterproto.message_field(7, group="_acceleration")
    gyro: "Gyro" = betterproto.message_field(8, group="_gyro")
    trip_id: str = betterproto.string_field(9, group="_trip_id")
    provider: str = betterproto.string_field(10, group="_provider")
    make: str = betterproto.string_field(11, group="_make")
    model: str = betterproto.string_field(12, group="_model")
    odo: float = betterproto.double_field(13)
    labels: Dict[str, str] = betterproto.map_field(
        6, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class Position(betterproto.Message):
    latlng: "LatLng" = betterproto.message_field(1)
    speed: float = betterproto.double_field(2, group="_speed")
    bearing: float = betterproto.double_field(3, group="_bearing")


@dataclass
class Acceleration(betterproto.Message):
    """
    * Acceleration is measured in gforce so if the vehicle is accelerating at
    9.8m/s^2 (newtons) in the x axis, the input to this api should be
    Acceleration { 1, 0, 0 } if it is decelerating at 1m/s^2, the input to this
    api should be { -0.102, 0, 0 } (0.102 ~= 1/9.8) if this is confusing, don't
    worry to hard about getting it correct, we can apply provider specific unit
    conversions post ingestion, just be consistent and let us know Note that
    the vertical axis in the diagram is the z axis, not the y axis Also note
    the + and - signs in the diagram which direction should be positive and
    negative within each axis ![alt
    text](https://storage.googleapis.com/compass-public-
    docs/static/acc_gyro.png)
    """

    x: float = betterproto.double_field(1, group="_x")
    y: float = betterproto.double_field(2, group="_y")
    z: float = betterproto.double_field(3, group="_z")


@dataclass
class Gyro(betterproto.Message):
    """
    * Rotational data is measured in degrees per second A positive value for
    roll, pitch or yaw is defined in the anti-clockwise direction when facing
    the positive direction of it's axis See acceleration diagram for more
    details
    """

    roll: float = betterproto.double_field(1, group="_roll")
    pitch: float = betterproto.double_field(2, group="_pitch")
    yaw: float = betterproto.double_field(3, group="_yaw")


@dataclass
class Stat(betterproto.Message):
    avg: float = betterproto.double_field(1)
    median: float = betterproto.double_field(2)
    percentile85: float = betterproto.double_field(3)


@dataclass
class TimeRange(betterproto.Message):
    start: datetime = betterproto.message_field(1)
    end: datetime = betterproto.message_field(2)


@dataclass
class DateTimeRange(betterproto.Message):
    start: "LocalDate" = betterproto.message_field(1)
    end: "LocalDate" = betterproto.message_field(2)
    # list of hours in each day e.g. [8,9,10,3,4] implies 8am - 11am + 3pm - 5pm
    hour_of_day: List[int] = betterproto.uint32_field(3)
    day_of_week: List["DayOfWeek"] = betterproto.enum_field(4)


@dataclass
class LocalDate(betterproto.Message):
    """Date in local area"""

    # day of month, [1,31]; 25
    day: int = betterproto.uint32_field(1)
    # month of year, [1,12]; 12
    month: int = betterproto.uint32_field(2)
    # year; 2021
    year: int = betterproto.uint32_field(3)


@dataclass
class LocalDateHour(betterproto.Message):
    """Date and hour in local area"""

    # day of month, [1,31]; 25
    day: int = betterproto.uint32_field(1)
    # month of year, [1,12]; 12
    month: int = betterproto.uint32_field(2)
    # year; 2021
    year: int = betterproto.uint32_field(3)
    # hour of day; 23
    hour: int = betterproto.uint32_field(4)
